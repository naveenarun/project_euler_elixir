## Project Euler in Elixir

## What is Elixir?

Elixir is a functional language. Its main application is for building scalable applications. One advantage of Elixir is that it makes parallel processing very simple and elegant to implement thanks to its actor model. Elixir's actor model involves actors that have mailboxes. The actors can receive mail and do something with it, and send mail to communicate with other actors. The main thread is also considered an actor. This model makes it easy to create your OWN parallel functions with custom behavior, which is quite nice considering the functionality is baked into the language and concise. In other languages/toolsets, you'd have to write lots of boilerplate, or at least install yet another dependency, to get the same kind of functionality. And it scales well too, so you can take your application from development to production quite seamlessly.

### My thoughts on Elixir as a whole

Elixir runs on the Erlang virtual machine (BEAM). As of the time of writing, I don't have any personal experience with Erlang, so I'm not qualified to talk about the differences between Elixir and Erlang. However, one thing to mention is that the Erlang virtual machine handles scaling pretty well, which is a huge plus if you want to build something that will eventually go into production.

Elixir has all the typical data structures built in (namely list, tuple, map/dict), although I have to mention that using linked lists as the default list type is a bit... questionable. I peronally tend to think in terms of memory-allocated sequential lists, so I found myself preferring to use tuples instead. There seem to be very few benefits to the linked lists, as highlighted by this StackOverflow thread: https://stackoverflow.com/questions/31192923/lists-vs-tuples-what-to-use-and-when. Although I guess if you have an application where the number of arguments to something is changing and not necessarily bounded, then it makes sense to use a linked list. Overall, Elixir is decent for math (considering that Erlang's libraries are still available), but I think the language shines brighter for use cases related to high-traffic server backends, interfacing with databases, etc. I would not use the language for scientific programming or system scripting, as the math on BEAM is kind of slow (see https://stackoverflow.com/questions/13629142/why-is-erlang-slower-than-java-on-all-these-small-math-benchmarks).

A side note about data types: I really like the use of atoms for state messaging. For some reason, using strings or aliased constants to handle states and errors rubs me the wrong way, while defining an entire Exception/Error/State class to handle states and errors also seems kind of overboard. The use of atoms seems like a sweet spot between the two. For example, if you want to parse an error flag, like `ERROR_INVALID_NAME` (which you'd assign an int constant to in C, for example) or `class InvalidNameError` (which you'd have to define on your own in Python), you can just send the atom `:InvalidNameError` instead of `:ok`. People don't talk about this feature too much but I think it's good to appreciate - it sort of gets to the core of how a state should intuitively be represented without unnecessary boilerplate. Other features that I enjoy are its clean syntax and UNIX-like pipes.

The language as a whole is quite fascinating. As of the time of writing, I haven't had too much experience with functional languages (other than Mathematica and some functional-ish aspects of Python), so the idea of having very few actual "variables" kind of threw me off. Instead, almost all variables are temporary and are passed through functions. Another interesting thing is that if..else statements and the like are themselves functions, and aren't used procedurally. The result of the if statement is the value of the last statement in it, and thus you have the structure `a = if..else` rather than the typical `if(condition) a=x, else a=y`.
